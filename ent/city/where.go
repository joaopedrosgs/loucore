// Code generated by entc, DO NOT EDIT.

package city

import (
	"time"

	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
	"github.com/joaopedrosgs/loucore/ent/predicate"
)

// ID filters vertices based on their identifier.
func ID(id int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// X applies equality check predicate on the "x" field. It's identical to XEQ.
func X(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldX), v))
	})
}

// Y applies equality check predicate on the "y" field. It's identical to YEQ.
func Y(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldY), v))
	})
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// Points applies equality check predicate on the "points" field. It's identical to PointsEQ.
func Points(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPoints), v))
	})
}

// WoodProduction applies equality check predicate on the "wood_production" field. It's identical to WoodProductionEQ.
func WoodProduction(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWoodProduction), v))
	})
}

// StoneProduction applies equality check predicate on the "stone_production" field. It's identical to StoneProductionEQ.
func StoneProduction(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStoneProduction), v))
	})
}

// IronProduction applies equality check predicate on the "iron_production" field. It's identical to IronProductionEQ.
func IronProduction(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIronProduction), v))
	})
}

// FoodProduction applies equality check predicate on the "food_production" field. It's identical to FoodProductionEQ.
func FoodProduction(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFoodProduction), v))
	})
}

// WoodStored applies equality check predicate on the "wood_stored" field. It's identical to WoodStoredEQ.
func WoodStored(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWoodStored), v))
	})
}

// StoneStored applies equality check predicate on the "stone_stored" field. It's identical to StoneStoredEQ.
func StoneStored(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStoneStored), v))
	})
}

// IronStored applies equality check predicate on the "iron_stored" field. It's identical to IronStoredEQ.
func IronStored(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIronStored), v))
	})
}

// FoodStored applies equality check predicate on the "food_stored" field. It's identical to FoodStoredEQ.
func FoodStored(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFoodStored), v))
	})
}

// WoodLimit applies equality check predicate on the "wood_limit" field. It's identical to WoodLimitEQ.
func WoodLimit(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWoodLimit), v))
	})
}

// StoneLimit applies equality check predicate on the "stone_limit" field. It's identical to StoneLimitEQ.
func StoneLimit(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStoneLimit), v))
	})
}

// IronLimit applies equality check predicate on the "iron_limit" field. It's identical to IronLimitEQ.
func IronLimit(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIronLimit), v))
	})
}

// FoodLimit applies equality check predicate on the "food_limit" field. It's identical to FoodLimitEQ.
func FoodLimit(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFoodLimit), v))
	})
}

// QueueStartedAt applies equality check predicate on the "queue_started_at" field. It's identical to QueueStartedAtEQ.
func QueueStartedAt(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQueueStartedAt), v))
	})
}

// QueueEndsAt applies equality check predicate on the "queue_ends_at" field. It's identical to QueueEndsAtEQ.
func QueueEndsAt(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQueueEndsAt), v))
	})
}

// ConstructionSpeed applies equality check predicate on the "construction_speed" field. It's identical to ConstructionSpeedEQ.
func ConstructionSpeed(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldConstructionSpeed), v))
	})
}

// LastUpdated applies equality check predicate on the "last_updated" field. It's identical to LastUpdatedEQ.
func LastUpdated(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastUpdated), v))
	})
}

// XEQ applies the EQ predicate on the "x" field.
func XEQ(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldX), v))
	})
}

// XNEQ applies the NEQ predicate on the "x" field.
func XNEQ(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldX), v))
	})
}

// XIn applies the In predicate on the "x" field.
func XIn(vs ...int) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldX), v...))
	})
}

// XNotIn applies the NotIn predicate on the "x" field.
func XNotIn(vs ...int) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldX), v...))
	})
}

// XGT applies the GT predicate on the "x" field.
func XGT(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldX), v))
	})
}

// XGTE applies the GTE predicate on the "x" field.
func XGTE(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldX), v))
	})
}

// XLT applies the LT predicate on the "x" field.
func XLT(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldX), v))
	})
}

// XLTE applies the LTE predicate on the "x" field.
func XLTE(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldX), v))
	})
}

// YEQ applies the EQ predicate on the "y" field.
func YEQ(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldY), v))
	})
}

// YNEQ applies the NEQ predicate on the "y" field.
func YNEQ(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldY), v))
	})
}

// YIn applies the In predicate on the "y" field.
func YIn(vs ...int) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldY), v...))
	})
}

// YNotIn applies the NotIn predicate on the "y" field.
func YNotIn(vs ...int) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldY), v...))
	})
}

// YGT applies the GT predicate on the "y" field.
func YGT(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldY), v))
	})
}

// YGTE applies the GTE predicate on the "y" field.
func YGTE(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldY), v))
	})
}

// YLT applies the LT predicate on the "y" field.
func YLT(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldY), v))
	})
}

// YLTE applies the LTE predicate on the "y" field.
func YLTE(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldY), v))
	})
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldName), v))
	})
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldName), v...))
	})
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldName), v...))
	})
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldName), v))
	})
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldName), v))
	})
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldName), v))
	})
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldName), v))
	})
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldName), v))
	})
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldName), v))
	})
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldName), v))
	})
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldName), v))
	})
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldName), v))
	})
}

// PointsEQ applies the EQ predicate on the "points" field.
func PointsEQ(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPoints), v))
	})
}

// PointsNEQ applies the NEQ predicate on the "points" field.
func PointsNEQ(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPoints), v))
	})
}

// PointsIn applies the In predicate on the "points" field.
func PointsIn(vs ...int) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPoints), v...))
	})
}

// PointsNotIn applies the NotIn predicate on the "points" field.
func PointsNotIn(vs ...int) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPoints), v...))
	})
}

// PointsGT applies the GT predicate on the "points" field.
func PointsGT(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPoints), v))
	})
}

// PointsGTE applies the GTE predicate on the "points" field.
func PointsGTE(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPoints), v))
	})
}

// PointsLT applies the LT predicate on the "points" field.
func PointsLT(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPoints), v))
	})
}

// PointsLTE applies the LTE predicate on the "points" field.
func PointsLTE(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPoints), v))
	})
}

// WoodProductionEQ applies the EQ predicate on the "wood_production" field.
func WoodProductionEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWoodProduction), v))
	})
}

// WoodProductionNEQ applies the NEQ predicate on the "wood_production" field.
func WoodProductionNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWoodProduction), v))
	})
}

// WoodProductionIn applies the In predicate on the "wood_production" field.
func WoodProductionIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWoodProduction), v...))
	})
}

// WoodProductionNotIn applies the NotIn predicate on the "wood_production" field.
func WoodProductionNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWoodProduction), v...))
	})
}

// WoodProductionGT applies the GT predicate on the "wood_production" field.
func WoodProductionGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWoodProduction), v))
	})
}

// WoodProductionGTE applies the GTE predicate on the "wood_production" field.
func WoodProductionGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWoodProduction), v))
	})
}

// WoodProductionLT applies the LT predicate on the "wood_production" field.
func WoodProductionLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWoodProduction), v))
	})
}

// WoodProductionLTE applies the LTE predicate on the "wood_production" field.
func WoodProductionLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWoodProduction), v))
	})
}

// StoneProductionEQ applies the EQ predicate on the "stone_production" field.
func StoneProductionEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStoneProduction), v))
	})
}

// StoneProductionNEQ applies the NEQ predicate on the "stone_production" field.
func StoneProductionNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStoneProduction), v))
	})
}

// StoneProductionIn applies the In predicate on the "stone_production" field.
func StoneProductionIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStoneProduction), v...))
	})
}

// StoneProductionNotIn applies the NotIn predicate on the "stone_production" field.
func StoneProductionNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStoneProduction), v...))
	})
}

// StoneProductionGT applies the GT predicate on the "stone_production" field.
func StoneProductionGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStoneProduction), v))
	})
}

// StoneProductionGTE applies the GTE predicate on the "stone_production" field.
func StoneProductionGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStoneProduction), v))
	})
}

// StoneProductionLT applies the LT predicate on the "stone_production" field.
func StoneProductionLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStoneProduction), v))
	})
}

// StoneProductionLTE applies the LTE predicate on the "stone_production" field.
func StoneProductionLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStoneProduction), v))
	})
}

// IronProductionEQ applies the EQ predicate on the "iron_production" field.
func IronProductionEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIronProduction), v))
	})
}

// IronProductionNEQ applies the NEQ predicate on the "iron_production" field.
func IronProductionNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIronProduction), v))
	})
}

// IronProductionIn applies the In predicate on the "iron_production" field.
func IronProductionIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldIronProduction), v...))
	})
}

// IronProductionNotIn applies the NotIn predicate on the "iron_production" field.
func IronProductionNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldIronProduction), v...))
	})
}

// IronProductionGT applies the GT predicate on the "iron_production" field.
func IronProductionGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldIronProduction), v))
	})
}

// IronProductionGTE applies the GTE predicate on the "iron_production" field.
func IronProductionGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldIronProduction), v))
	})
}

// IronProductionLT applies the LT predicate on the "iron_production" field.
func IronProductionLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldIronProduction), v))
	})
}

// IronProductionLTE applies the LTE predicate on the "iron_production" field.
func IronProductionLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldIronProduction), v))
	})
}

// FoodProductionEQ applies the EQ predicate on the "food_production" field.
func FoodProductionEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFoodProduction), v))
	})
}

// FoodProductionNEQ applies the NEQ predicate on the "food_production" field.
func FoodProductionNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFoodProduction), v))
	})
}

// FoodProductionIn applies the In predicate on the "food_production" field.
func FoodProductionIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFoodProduction), v...))
	})
}

// FoodProductionNotIn applies the NotIn predicate on the "food_production" field.
func FoodProductionNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFoodProduction), v...))
	})
}

// FoodProductionGT applies the GT predicate on the "food_production" field.
func FoodProductionGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFoodProduction), v))
	})
}

// FoodProductionGTE applies the GTE predicate on the "food_production" field.
func FoodProductionGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFoodProduction), v))
	})
}

// FoodProductionLT applies the LT predicate on the "food_production" field.
func FoodProductionLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFoodProduction), v))
	})
}

// FoodProductionLTE applies the LTE predicate on the "food_production" field.
func FoodProductionLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFoodProduction), v))
	})
}

// WoodStoredEQ applies the EQ predicate on the "wood_stored" field.
func WoodStoredEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWoodStored), v))
	})
}

// WoodStoredNEQ applies the NEQ predicate on the "wood_stored" field.
func WoodStoredNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWoodStored), v))
	})
}

// WoodStoredIn applies the In predicate on the "wood_stored" field.
func WoodStoredIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWoodStored), v...))
	})
}

// WoodStoredNotIn applies the NotIn predicate on the "wood_stored" field.
func WoodStoredNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWoodStored), v...))
	})
}

// WoodStoredGT applies the GT predicate on the "wood_stored" field.
func WoodStoredGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWoodStored), v))
	})
}

// WoodStoredGTE applies the GTE predicate on the "wood_stored" field.
func WoodStoredGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWoodStored), v))
	})
}

// WoodStoredLT applies the LT predicate on the "wood_stored" field.
func WoodStoredLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWoodStored), v))
	})
}

// WoodStoredLTE applies the LTE predicate on the "wood_stored" field.
func WoodStoredLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWoodStored), v))
	})
}

// StoneStoredEQ applies the EQ predicate on the "stone_stored" field.
func StoneStoredEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStoneStored), v))
	})
}

// StoneStoredNEQ applies the NEQ predicate on the "stone_stored" field.
func StoneStoredNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStoneStored), v))
	})
}

// StoneStoredIn applies the In predicate on the "stone_stored" field.
func StoneStoredIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStoneStored), v...))
	})
}

// StoneStoredNotIn applies the NotIn predicate on the "stone_stored" field.
func StoneStoredNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStoneStored), v...))
	})
}

// StoneStoredGT applies the GT predicate on the "stone_stored" field.
func StoneStoredGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStoneStored), v))
	})
}

// StoneStoredGTE applies the GTE predicate on the "stone_stored" field.
func StoneStoredGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStoneStored), v))
	})
}

// StoneStoredLT applies the LT predicate on the "stone_stored" field.
func StoneStoredLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStoneStored), v))
	})
}

// StoneStoredLTE applies the LTE predicate on the "stone_stored" field.
func StoneStoredLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStoneStored), v))
	})
}

// IronStoredEQ applies the EQ predicate on the "iron_stored" field.
func IronStoredEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIronStored), v))
	})
}

// IronStoredNEQ applies the NEQ predicate on the "iron_stored" field.
func IronStoredNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIronStored), v))
	})
}

// IronStoredIn applies the In predicate on the "iron_stored" field.
func IronStoredIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldIronStored), v...))
	})
}

// IronStoredNotIn applies the NotIn predicate on the "iron_stored" field.
func IronStoredNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldIronStored), v...))
	})
}

// IronStoredGT applies the GT predicate on the "iron_stored" field.
func IronStoredGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldIronStored), v))
	})
}

// IronStoredGTE applies the GTE predicate on the "iron_stored" field.
func IronStoredGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldIronStored), v))
	})
}

// IronStoredLT applies the LT predicate on the "iron_stored" field.
func IronStoredLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldIronStored), v))
	})
}

// IronStoredLTE applies the LTE predicate on the "iron_stored" field.
func IronStoredLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldIronStored), v))
	})
}

// FoodStoredEQ applies the EQ predicate on the "food_stored" field.
func FoodStoredEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFoodStored), v))
	})
}

// FoodStoredNEQ applies the NEQ predicate on the "food_stored" field.
func FoodStoredNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFoodStored), v))
	})
}

// FoodStoredIn applies the In predicate on the "food_stored" field.
func FoodStoredIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFoodStored), v...))
	})
}

// FoodStoredNotIn applies the NotIn predicate on the "food_stored" field.
func FoodStoredNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFoodStored), v...))
	})
}

// FoodStoredGT applies the GT predicate on the "food_stored" field.
func FoodStoredGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFoodStored), v))
	})
}

// FoodStoredGTE applies the GTE predicate on the "food_stored" field.
func FoodStoredGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFoodStored), v))
	})
}

// FoodStoredLT applies the LT predicate on the "food_stored" field.
func FoodStoredLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFoodStored), v))
	})
}

// FoodStoredLTE applies the LTE predicate on the "food_stored" field.
func FoodStoredLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFoodStored), v))
	})
}

// WoodLimitEQ applies the EQ predicate on the "wood_limit" field.
func WoodLimitEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWoodLimit), v))
	})
}

// WoodLimitNEQ applies the NEQ predicate on the "wood_limit" field.
func WoodLimitNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWoodLimit), v))
	})
}

// WoodLimitIn applies the In predicate on the "wood_limit" field.
func WoodLimitIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWoodLimit), v...))
	})
}

// WoodLimitNotIn applies the NotIn predicate on the "wood_limit" field.
func WoodLimitNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWoodLimit), v...))
	})
}

// WoodLimitGT applies the GT predicate on the "wood_limit" field.
func WoodLimitGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWoodLimit), v))
	})
}

// WoodLimitGTE applies the GTE predicate on the "wood_limit" field.
func WoodLimitGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWoodLimit), v))
	})
}

// WoodLimitLT applies the LT predicate on the "wood_limit" field.
func WoodLimitLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWoodLimit), v))
	})
}

// WoodLimitLTE applies the LTE predicate on the "wood_limit" field.
func WoodLimitLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWoodLimit), v))
	})
}

// StoneLimitEQ applies the EQ predicate on the "stone_limit" field.
func StoneLimitEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStoneLimit), v))
	})
}

// StoneLimitNEQ applies the NEQ predicate on the "stone_limit" field.
func StoneLimitNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStoneLimit), v))
	})
}

// StoneLimitIn applies the In predicate on the "stone_limit" field.
func StoneLimitIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStoneLimit), v...))
	})
}

// StoneLimitNotIn applies the NotIn predicate on the "stone_limit" field.
func StoneLimitNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStoneLimit), v...))
	})
}

// StoneLimitGT applies the GT predicate on the "stone_limit" field.
func StoneLimitGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStoneLimit), v))
	})
}

// StoneLimitGTE applies the GTE predicate on the "stone_limit" field.
func StoneLimitGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStoneLimit), v))
	})
}

// StoneLimitLT applies the LT predicate on the "stone_limit" field.
func StoneLimitLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStoneLimit), v))
	})
}

// StoneLimitLTE applies the LTE predicate on the "stone_limit" field.
func StoneLimitLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStoneLimit), v))
	})
}

// IronLimitEQ applies the EQ predicate on the "iron_limit" field.
func IronLimitEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIronLimit), v))
	})
}

// IronLimitNEQ applies the NEQ predicate on the "iron_limit" field.
func IronLimitNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIronLimit), v))
	})
}

// IronLimitIn applies the In predicate on the "iron_limit" field.
func IronLimitIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldIronLimit), v...))
	})
}

// IronLimitNotIn applies the NotIn predicate on the "iron_limit" field.
func IronLimitNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldIronLimit), v...))
	})
}

// IronLimitGT applies the GT predicate on the "iron_limit" field.
func IronLimitGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldIronLimit), v))
	})
}

// IronLimitGTE applies the GTE predicate on the "iron_limit" field.
func IronLimitGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldIronLimit), v))
	})
}

// IronLimitLT applies the LT predicate on the "iron_limit" field.
func IronLimitLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldIronLimit), v))
	})
}

// IronLimitLTE applies the LTE predicate on the "iron_limit" field.
func IronLimitLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldIronLimit), v))
	})
}

// FoodLimitEQ applies the EQ predicate on the "food_limit" field.
func FoodLimitEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFoodLimit), v))
	})
}

// FoodLimitNEQ applies the NEQ predicate on the "food_limit" field.
func FoodLimitNEQ(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFoodLimit), v))
	})
}

// FoodLimitIn applies the In predicate on the "food_limit" field.
func FoodLimitIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFoodLimit), v...))
	})
}

// FoodLimitNotIn applies the NotIn predicate on the "food_limit" field.
func FoodLimitNotIn(vs ...float64) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFoodLimit), v...))
	})
}

// FoodLimitGT applies the GT predicate on the "food_limit" field.
func FoodLimitGT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFoodLimit), v))
	})
}

// FoodLimitGTE applies the GTE predicate on the "food_limit" field.
func FoodLimitGTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFoodLimit), v))
	})
}

// FoodLimitLT applies the LT predicate on the "food_limit" field.
func FoodLimitLT(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFoodLimit), v))
	})
}

// FoodLimitLTE applies the LTE predicate on the "food_limit" field.
func FoodLimitLTE(v float64) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFoodLimit), v))
	})
}

// QueueStartedAtEQ applies the EQ predicate on the "queue_started_at" field.
func QueueStartedAtEQ(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQueueStartedAt), v))
	})
}

// QueueStartedAtNEQ applies the NEQ predicate on the "queue_started_at" field.
func QueueStartedAtNEQ(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldQueueStartedAt), v))
	})
}

// QueueStartedAtIn applies the In predicate on the "queue_started_at" field.
func QueueStartedAtIn(vs ...time.Time) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldQueueStartedAt), v...))
	})
}

// QueueStartedAtNotIn applies the NotIn predicate on the "queue_started_at" field.
func QueueStartedAtNotIn(vs ...time.Time) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldQueueStartedAt), v...))
	})
}

// QueueStartedAtGT applies the GT predicate on the "queue_started_at" field.
func QueueStartedAtGT(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldQueueStartedAt), v))
	})
}

// QueueStartedAtGTE applies the GTE predicate on the "queue_started_at" field.
func QueueStartedAtGTE(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldQueueStartedAt), v))
	})
}

// QueueStartedAtLT applies the LT predicate on the "queue_started_at" field.
func QueueStartedAtLT(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldQueueStartedAt), v))
	})
}

// QueueStartedAtLTE applies the LTE predicate on the "queue_started_at" field.
func QueueStartedAtLTE(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldQueueStartedAt), v))
	})
}

// QueueEndsAtEQ applies the EQ predicate on the "queue_ends_at" field.
func QueueEndsAtEQ(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQueueEndsAt), v))
	})
}

// QueueEndsAtNEQ applies the NEQ predicate on the "queue_ends_at" field.
func QueueEndsAtNEQ(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldQueueEndsAt), v))
	})
}

// QueueEndsAtIn applies the In predicate on the "queue_ends_at" field.
func QueueEndsAtIn(vs ...time.Time) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldQueueEndsAt), v...))
	})
}

// QueueEndsAtNotIn applies the NotIn predicate on the "queue_ends_at" field.
func QueueEndsAtNotIn(vs ...time.Time) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldQueueEndsAt), v...))
	})
}

// QueueEndsAtGT applies the GT predicate on the "queue_ends_at" field.
func QueueEndsAtGT(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldQueueEndsAt), v))
	})
}

// QueueEndsAtGTE applies the GTE predicate on the "queue_ends_at" field.
func QueueEndsAtGTE(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldQueueEndsAt), v))
	})
}

// QueueEndsAtLT applies the LT predicate on the "queue_ends_at" field.
func QueueEndsAtLT(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldQueueEndsAt), v))
	})
}

// QueueEndsAtLTE applies the LTE predicate on the "queue_ends_at" field.
func QueueEndsAtLTE(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldQueueEndsAt), v))
	})
}

// ConstructionSpeedEQ applies the EQ predicate on the "construction_speed" field.
func ConstructionSpeedEQ(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldConstructionSpeed), v))
	})
}

// ConstructionSpeedNEQ applies the NEQ predicate on the "construction_speed" field.
func ConstructionSpeedNEQ(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldConstructionSpeed), v))
	})
}

// ConstructionSpeedIn applies the In predicate on the "construction_speed" field.
func ConstructionSpeedIn(vs ...int) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldConstructionSpeed), v...))
	})
}

// ConstructionSpeedNotIn applies the NotIn predicate on the "construction_speed" field.
func ConstructionSpeedNotIn(vs ...int) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldConstructionSpeed), v...))
	})
}

// ConstructionSpeedGT applies the GT predicate on the "construction_speed" field.
func ConstructionSpeedGT(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldConstructionSpeed), v))
	})
}

// ConstructionSpeedGTE applies the GTE predicate on the "construction_speed" field.
func ConstructionSpeedGTE(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldConstructionSpeed), v))
	})
}

// ConstructionSpeedLT applies the LT predicate on the "construction_speed" field.
func ConstructionSpeedLT(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldConstructionSpeed), v))
	})
}

// ConstructionSpeedLTE applies the LTE predicate on the "construction_speed" field.
func ConstructionSpeedLTE(v int) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldConstructionSpeed), v))
	})
}

// LastUpdatedEQ applies the EQ predicate on the "last_updated" field.
func LastUpdatedEQ(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastUpdated), v))
	})
}

// LastUpdatedNEQ applies the NEQ predicate on the "last_updated" field.
func LastUpdatedNEQ(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastUpdated), v))
	})
}

// LastUpdatedIn applies the In predicate on the "last_updated" field.
func LastUpdatedIn(vs ...time.Time) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastUpdated), v...))
	})
}

// LastUpdatedNotIn applies the NotIn predicate on the "last_updated" field.
func LastUpdatedNotIn(vs ...time.Time) predicate.City {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.City(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastUpdated), v...))
	})
}

// LastUpdatedGT applies the GT predicate on the "last_updated" field.
func LastUpdatedGT(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastUpdated), v))
	})
}

// LastUpdatedGTE applies the GTE predicate on the "last_updated" field.
func LastUpdatedGTE(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastUpdated), v))
	})
}

// LastUpdatedLT applies the LT predicate on the "last_updated" field.
func LastUpdatedLT(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastUpdated), v))
	})
}

// LastUpdatedLTE applies the LTE predicate on the "last_updated" field.
func LastUpdatedLTE(v time.Time) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastUpdated), v))
	})
}

// HasOwner applies the HasEdge predicate on the "owner" edge.
func HasOwner() predicate.City {
	return predicate.City(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(OwnerTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, OwnerTable, OwnerColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasOwnerWith applies the HasEdge predicate on the "owner" edge with a given conditions (other predicates).
func HasOwnerWith(preds ...predicate.User) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(OwnerInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, OwnerTable, OwnerColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasConstructions applies the HasEdge predicate on the "constructions" edge.
func HasConstructions() predicate.City {
	return predicate.City(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ConstructionsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ConstructionsTable, ConstructionsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasConstructionsWith applies the HasEdge predicate on the "constructions" edge with a given conditions (other predicates).
func HasConstructionsWith(preds ...predicate.Construction) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ConstructionsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ConstructionsTable, ConstructionsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasQueue applies the HasEdge predicate on the "queue" edge.
func HasQueue() predicate.City {
	return predicate.City(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(QueueTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, QueueTable, QueueColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasQueueWith applies the HasEdge predicate on the "queue" edge with a given conditions (other predicates).
func HasQueueWith(preds ...predicate.QueueItem) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(QueueInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, QueueTable, QueueColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups list of predicates with the AND operator between them.
func And(predicates ...predicate.City) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups list of predicates with the OR operator between them.
func Or(predicates ...predicate.City) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.City) predicate.City {
	return predicate.City(func(s *sql.Selector) {
		p(s.Not())
	})
}
