// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/joaopedrosgs/loucore/ent/city"
	"github.com/joaopedrosgs/loucore/ent/construction"
	"github.com/joaopedrosgs/loucore/ent/queueitem"
	"github.com/joaopedrosgs/loucore/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCity         = "City"
	TypeConstruction = "Construction"
	TypeQueueItem    = "QueueItem"
	TypeUser         = "User"
)

// CityMutation represents an operation that mutate the Cities
// nodes in the graph.
type CityMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	x                     *int
	addx                  *int
	y                     *int
	addy                  *int
	name                  *string
	points                *int
	addpoints             *int
	wood_production       *int
	addwood_production    *int
	stone_production      *int
	addstone_production   *int
	iron_production       *int
	addiron_production    *int
	food_production       *int
	addfood_production    *int
	wood_stored           *int
	addwood_stored        *int
	stone_stored          *int
	addstone_stored       *int
	iron_stored           *int
	addiron_stored        *int
	food_stored           *int
	addfood_stored        *int
	wood_limit            *int
	addwood_limit         *int
	stone_limit           *int
	addstone_limit        *int
	iron_limit            *int
	addiron_limit         *int
	food_limit            *int
	addfood_limit         *int
	queue_time            *time.Time
	construction_speed    *int
	addconstruction_speed *int
	clearedFields         map[string]struct{}
	owner                 *int
	clearedowner          bool
	constructions         map[int]struct{}
	removedconstructions  map[int]struct{}
	queue                 map[int]struct{}
	removedqueue          map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*City, error)
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows to manage the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for $n.Name.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the id field of the mutation.
func withCityID(id int) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetX sets the x field.
func (m *CityMutation) SetX(i int) {
	m.x = &i
	m.addx = nil
}

// X returns the x value in the mutation.
func (m *CityMutation) X() (r int, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old x value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldX is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// AddX adds i to x.
func (m *CityMutation) AddX(i int) {
	if m.addx != nil {
		*m.addx += i
	} else {
		m.addx = &i
	}
}

// AddedX returns the value that was added to the x field in this mutation.
func (m *CityMutation) AddedX() (r int, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX reset all changes of the "x" field.
func (m *CityMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the y field.
func (m *CityMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the y value in the mutation.
func (m *CityMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old y value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to y.
func (m *CityMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the y field in this mutation.
func (m *CityMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY reset all changes of the "y" field.
func (m *CityMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetName sets the name field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetPoints sets the points field.
func (m *CityMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the points value in the mutation.
func (m *CityMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old points value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPoints is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to points.
func (m *CityMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the points field in this mutation.
func (m *CityMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints reset all changes of the "points" field.
func (m *CityMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetWoodProduction sets the wood_production field.
func (m *CityMutation) SetWoodProduction(i int) {
	m.wood_production = &i
	m.addwood_production = nil
}

// WoodProduction returns the wood_production value in the mutation.
func (m *CityMutation) WoodProduction() (r int, exists bool) {
	v := m.wood_production
	if v == nil {
		return
	}
	return *v, true
}

// OldWoodProduction returns the old wood_production value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldWoodProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWoodProduction is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWoodProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWoodProduction: %w", err)
	}
	return oldValue.WoodProduction, nil
}

// AddWoodProduction adds i to wood_production.
func (m *CityMutation) AddWoodProduction(i int) {
	if m.addwood_production != nil {
		*m.addwood_production += i
	} else {
		m.addwood_production = &i
	}
}

// AddedWoodProduction returns the value that was added to the wood_production field in this mutation.
func (m *CityMutation) AddedWoodProduction() (r int, exists bool) {
	v := m.addwood_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetWoodProduction reset all changes of the "wood_production" field.
func (m *CityMutation) ResetWoodProduction() {
	m.wood_production = nil
	m.addwood_production = nil
}

// SetStoneProduction sets the stone_production field.
func (m *CityMutation) SetStoneProduction(i int) {
	m.stone_production = &i
	m.addstone_production = nil
}

// StoneProduction returns the stone_production value in the mutation.
func (m *CityMutation) StoneProduction() (r int, exists bool) {
	v := m.stone_production
	if v == nil {
		return
	}
	return *v, true
}

// OldStoneProduction returns the old stone_production value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldStoneProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStoneProduction is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStoneProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoneProduction: %w", err)
	}
	return oldValue.StoneProduction, nil
}

// AddStoneProduction adds i to stone_production.
func (m *CityMutation) AddStoneProduction(i int) {
	if m.addstone_production != nil {
		*m.addstone_production += i
	} else {
		m.addstone_production = &i
	}
}

// AddedStoneProduction returns the value that was added to the stone_production field in this mutation.
func (m *CityMutation) AddedStoneProduction() (r int, exists bool) {
	v := m.addstone_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoneProduction reset all changes of the "stone_production" field.
func (m *CityMutation) ResetStoneProduction() {
	m.stone_production = nil
	m.addstone_production = nil
}

// SetIronProduction sets the iron_production field.
func (m *CityMutation) SetIronProduction(i int) {
	m.iron_production = &i
	m.addiron_production = nil
}

// IronProduction returns the iron_production value in the mutation.
func (m *CityMutation) IronProduction() (r int, exists bool) {
	v := m.iron_production
	if v == nil {
		return
	}
	return *v, true
}

// OldIronProduction returns the old iron_production value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldIronProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIronProduction is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIronProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIronProduction: %w", err)
	}
	return oldValue.IronProduction, nil
}

// AddIronProduction adds i to iron_production.
func (m *CityMutation) AddIronProduction(i int) {
	if m.addiron_production != nil {
		*m.addiron_production += i
	} else {
		m.addiron_production = &i
	}
}

// AddedIronProduction returns the value that was added to the iron_production field in this mutation.
func (m *CityMutation) AddedIronProduction() (r int, exists bool) {
	v := m.addiron_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetIronProduction reset all changes of the "iron_production" field.
func (m *CityMutation) ResetIronProduction() {
	m.iron_production = nil
	m.addiron_production = nil
}

// SetFoodProduction sets the food_production field.
func (m *CityMutation) SetFoodProduction(i int) {
	m.food_production = &i
	m.addfood_production = nil
}

// FoodProduction returns the food_production value in the mutation.
func (m *CityMutation) FoodProduction() (r int, exists bool) {
	v := m.food_production
	if v == nil {
		return
	}
	return *v, true
}

// OldFoodProduction returns the old food_production value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldFoodProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFoodProduction is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFoodProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFoodProduction: %w", err)
	}
	return oldValue.FoodProduction, nil
}

// AddFoodProduction adds i to food_production.
func (m *CityMutation) AddFoodProduction(i int) {
	if m.addfood_production != nil {
		*m.addfood_production += i
	} else {
		m.addfood_production = &i
	}
}

// AddedFoodProduction returns the value that was added to the food_production field in this mutation.
func (m *CityMutation) AddedFoodProduction() (r int, exists bool) {
	v := m.addfood_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetFoodProduction reset all changes of the "food_production" field.
func (m *CityMutation) ResetFoodProduction() {
	m.food_production = nil
	m.addfood_production = nil
}

// SetWoodStored sets the wood_stored field.
func (m *CityMutation) SetWoodStored(i int) {
	m.wood_stored = &i
	m.addwood_stored = nil
}

// WoodStored returns the wood_stored value in the mutation.
func (m *CityMutation) WoodStored() (r int, exists bool) {
	v := m.wood_stored
	if v == nil {
		return
	}
	return *v, true
}

// OldWoodStored returns the old wood_stored value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldWoodStored(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWoodStored is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWoodStored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWoodStored: %w", err)
	}
	return oldValue.WoodStored, nil
}

// AddWoodStored adds i to wood_stored.
func (m *CityMutation) AddWoodStored(i int) {
	if m.addwood_stored != nil {
		*m.addwood_stored += i
	} else {
		m.addwood_stored = &i
	}
}

// AddedWoodStored returns the value that was added to the wood_stored field in this mutation.
func (m *CityMutation) AddedWoodStored() (r int, exists bool) {
	v := m.addwood_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetWoodStored reset all changes of the "wood_stored" field.
func (m *CityMutation) ResetWoodStored() {
	m.wood_stored = nil
	m.addwood_stored = nil
}

// SetStoneStored sets the stone_stored field.
func (m *CityMutation) SetStoneStored(i int) {
	m.stone_stored = &i
	m.addstone_stored = nil
}

// StoneStored returns the stone_stored value in the mutation.
func (m *CityMutation) StoneStored() (r int, exists bool) {
	v := m.stone_stored
	if v == nil {
		return
	}
	return *v, true
}

// OldStoneStored returns the old stone_stored value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldStoneStored(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStoneStored is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStoneStored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoneStored: %w", err)
	}
	return oldValue.StoneStored, nil
}

// AddStoneStored adds i to stone_stored.
func (m *CityMutation) AddStoneStored(i int) {
	if m.addstone_stored != nil {
		*m.addstone_stored += i
	} else {
		m.addstone_stored = &i
	}
}

// AddedStoneStored returns the value that was added to the stone_stored field in this mutation.
func (m *CityMutation) AddedStoneStored() (r int, exists bool) {
	v := m.addstone_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoneStored reset all changes of the "stone_stored" field.
func (m *CityMutation) ResetStoneStored() {
	m.stone_stored = nil
	m.addstone_stored = nil
}

// SetIronStored sets the iron_stored field.
func (m *CityMutation) SetIronStored(i int) {
	m.iron_stored = &i
	m.addiron_stored = nil
}

// IronStored returns the iron_stored value in the mutation.
func (m *CityMutation) IronStored() (r int, exists bool) {
	v := m.iron_stored
	if v == nil {
		return
	}
	return *v, true
}

// OldIronStored returns the old iron_stored value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldIronStored(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIronStored is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIronStored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIronStored: %w", err)
	}
	return oldValue.IronStored, nil
}

// AddIronStored adds i to iron_stored.
func (m *CityMutation) AddIronStored(i int) {
	if m.addiron_stored != nil {
		*m.addiron_stored += i
	} else {
		m.addiron_stored = &i
	}
}

// AddedIronStored returns the value that was added to the iron_stored field in this mutation.
func (m *CityMutation) AddedIronStored() (r int, exists bool) {
	v := m.addiron_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetIronStored reset all changes of the "iron_stored" field.
func (m *CityMutation) ResetIronStored() {
	m.iron_stored = nil
	m.addiron_stored = nil
}

// SetFoodStored sets the food_stored field.
func (m *CityMutation) SetFoodStored(i int) {
	m.food_stored = &i
	m.addfood_stored = nil
}

// FoodStored returns the food_stored value in the mutation.
func (m *CityMutation) FoodStored() (r int, exists bool) {
	v := m.food_stored
	if v == nil {
		return
	}
	return *v, true
}

// OldFoodStored returns the old food_stored value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldFoodStored(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFoodStored is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFoodStored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFoodStored: %w", err)
	}
	return oldValue.FoodStored, nil
}

// AddFoodStored adds i to food_stored.
func (m *CityMutation) AddFoodStored(i int) {
	if m.addfood_stored != nil {
		*m.addfood_stored += i
	} else {
		m.addfood_stored = &i
	}
}

// AddedFoodStored returns the value that was added to the food_stored field in this mutation.
func (m *CityMutation) AddedFoodStored() (r int, exists bool) {
	v := m.addfood_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetFoodStored reset all changes of the "food_stored" field.
func (m *CityMutation) ResetFoodStored() {
	m.food_stored = nil
	m.addfood_stored = nil
}

// SetWoodLimit sets the wood_limit field.
func (m *CityMutation) SetWoodLimit(i int) {
	m.wood_limit = &i
	m.addwood_limit = nil
}

// WoodLimit returns the wood_limit value in the mutation.
func (m *CityMutation) WoodLimit() (r int, exists bool) {
	v := m.wood_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldWoodLimit returns the old wood_limit value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldWoodLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWoodLimit is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWoodLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWoodLimit: %w", err)
	}
	return oldValue.WoodLimit, nil
}

// AddWoodLimit adds i to wood_limit.
func (m *CityMutation) AddWoodLimit(i int) {
	if m.addwood_limit != nil {
		*m.addwood_limit += i
	} else {
		m.addwood_limit = &i
	}
}

// AddedWoodLimit returns the value that was added to the wood_limit field in this mutation.
func (m *CityMutation) AddedWoodLimit() (r int, exists bool) {
	v := m.addwood_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetWoodLimit reset all changes of the "wood_limit" field.
func (m *CityMutation) ResetWoodLimit() {
	m.wood_limit = nil
	m.addwood_limit = nil
}

// SetStoneLimit sets the stone_limit field.
func (m *CityMutation) SetStoneLimit(i int) {
	m.stone_limit = &i
	m.addstone_limit = nil
}

// StoneLimit returns the stone_limit value in the mutation.
func (m *CityMutation) StoneLimit() (r int, exists bool) {
	v := m.stone_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldStoneLimit returns the old stone_limit value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldStoneLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStoneLimit is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStoneLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoneLimit: %w", err)
	}
	return oldValue.StoneLimit, nil
}

// AddStoneLimit adds i to stone_limit.
func (m *CityMutation) AddStoneLimit(i int) {
	if m.addstone_limit != nil {
		*m.addstone_limit += i
	} else {
		m.addstone_limit = &i
	}
}

// AddedStoneLimit returns the value that was added to the stone_limit field in this mutation.
func (m *CityMutation) AddedStoneLimit() (r int, exists bool) {
	v := m.addstone_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoneLimit reset all changes of the "stone_limit" field.
func (m *CityMutation) ResetStoneLimit() {
	m.stone_limit = nil
	m.addstone_limit = nil
}

// SetIronLimit sets the iron_limit field.
func (m *CityMutation) SetIronLimit(i int) {
	m.iron_limit = &i
	m.addiron_limit = nil
}

// IronLimit returns the iron_limit value in the mutation.
func (m *CityMutation) IronLimit() (r int, exists bool) {
	v := m.iron_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIronLimit returns the old iron_limit value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldIronLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIronLimit is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIronLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIronLimit: %w", err)
	}
	return oldValue.IronLimit, nil
}

// AddIronLimit adds i to iron_limit.
func (m *CityMutation) AddIronLimit(i int) {
	if m.addiron_limit != nil {
		*m.addiron_limit += i
	} else {
		m.addiron_limit = &i
	}
}

// AddedIronLimit returns the value that was added to the iron_limit field in this mutation.
func (m *CityMutation) AddedIronLimit() (r int, exists bool) {
	v := m.addiron_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetIronLimit reset all changes of the "iron_limit" field.
func (m *CityMutation) ResetIronLimit() {
	m.iron_limit = nil
	m.addiron_limit = nil
}

// SetFoodLimit sets the food_limit field.
func (m *CityMutation) SetFoodLimit(i int) {
	m.food_limit = &i
	m.addfood_limit = nil
}

// FoodLimit returns the food_limit value in the mutation.
func (m *CityMutation) FoodLimit() (r int, exists bool) {
	v := m.food_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldFoodLimit returns the old food_limit value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldFoodLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFoodLimit is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFoodLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFoodLimit: %w", err)
	}
	return oldValue.FoodLimit, nil
}

// AddFoodLimit adds i to food_limit.
func (m *CityMutation) AddFoodLimit(i int) {
	if m.addfood_limit != nil {
		*m.addfood_limit += i
	} else {
		m.addfood_limit = &i
	}
}

// AddedFoodLimit returns the value that was added to the food_limit field in this mutation.
func (m *CityMutation) AddedFoodLimit() (r int, exists bool) {
	v := m.addfood_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetFoodLimit reset all changes of the "food_limit" field.
func (m *CityMutation) ResetFoodLimit() {
	m.food_limit = nil
	m.addfood_limit = nil
}

// SetQueueTime sets the queue_time field.
func (m *CityMutation) SetQueueTime(t time.Time) {
	m.queue_time = &t
}

// QueueTime returns the queue_time value in the mutation.
func (m *CityMutation) QueueTime() (r time.Time, exists bool) {
	v := m.queue_time
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueTime returns the old queue_time value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldQueueTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQueueTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQueueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueTime: %w", err)
	}
	return oldValue.QueueTime, nil
}

// ResetQueueTime reset all changes of the "queue_time" field.
func (m *CityMutation) ResetQueueTime() {
	m.queue_time = nil
}

// SetConstructionSpeed sets the construction_speed field.
func (m *CityMutation) SetConstructionSpeed(i int) {
	m.construction_speed = &i
	m.addconstruction_speed = nil
}

// ConstructionSpeed returns the construction_speed value in the mutation.
func (m *CityMutation) ConstructionSpeed() (r int, exists bool) {
	v := m.construction_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldConstructionSpeed returns the old construction_speed value of the City.
// If the City object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CityMutation) OldConstructionSpeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConstructionSpeed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConstructionSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstructionSpeed: %w", err)
	}
	return oldValue.ConstructionSpeed, nil
}

// AddConstructionSpeed adds i to construction_speed.
func (m *CityMutation) AddConstructionSpeed(i int) {
	if m.addconstruction_speed != nil {
		*m.addconstruction_speed += i
	} else {
		m.addconstruction_speed = &i
	}
}

// AddedConstructionSpeed returns the value that was added to the construction_speed field in this mutation.
func (m *CityMutation) AddedConstructionSpeed() (r int, exists bool) {
	v := m.addconstruction_speed
	if v == nil {
		return
	}
	return *v, true
}

// ResetConstructionSpeed reset all changes of the "construction_speed" field.
func (m *CityMutation) ResetConstructionSpeed() {
	m.construction_speed = nil
	m.addconstruction_speed = nil
}

// SetOwnerID sets the owner edge to User by id.
func (m *CityMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to User.
func (m *CityMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *CityMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *CityMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CityMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *CityMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddConstructionIDs adds the constructions edge to Construction by ids.
func (m *CityMutation) AddConstructionIDs(ids ...int) {
	if m.constructions == nil {
		m.constructions = make(map[int]struct{})
	}
	for i := range ids {
		m.constructions[ids[i]] = struct{}{}
	}
}

// RemoveConstructionIDs removes the constructions edge to Construction by ids.
func (m *CityMutation) RemoveConstructionIDs(ids ...int) {
	if m.removedconstructions == nil {
		m.removedconstructions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedconstructions[ids[i]] = struct{}{}
	}
}

// RemovedConstructions returns the removed ids of constructions.
func (m *CityMutation) RemovedConstructionsIDs() (ids []int) {
	for id := range m.removedconstructions {
		ids = append(ids, id)
	}
	return
}

// ConstructionsIDs returns the constructions ids in the mutation.
func (m *CityMutation) ConstructionsIDs() (ids []int) {
	for id := range m.constructions {
		ids = append(ids, id)
	}
	return
}

// ResetConstructions reset all changes of the "constructions" edge.
func (m *CityMutation) ResetConstructions() {
	m.constructions = nil
	m.removedconstructions = nil
}

// AddQueueIDs adds the queue edge to QueueItem by ids.
func (m *CityMutation) AddQueueIDs(ids ...int) {
	if m.queue == nil {
		m.queue = make(map[int]struct{})
	}
	for i := range ids {
		m.queue[ids[i]] = struct{}{}
	}
}

// RemoveQueueIDs removes the queue edge to QueueItem by ids.
func (m *CityMutation) RemoveQueueIDs(ids ...int) {
	if m.removedqueue == nil {
		m.removedqueue = make(map[int]struct{})
	}
	for i := range ids {
		m.removedqueue[ids[i]] = struct{}{}
	}
}

// RemovedQueue returns the removed ids of queue.
func (m *CityMutation) RemovedQueueIDs() (ids []int) {
	for id := range m.removedqueue {
		ids = append(ids, id)
	}
	return
}

// QueueIDs returns the queue ids in the mutation.
func (m *CityMutation) QueueIDs() (ids []int) {
	for id := range m.queue {
		ids = append(ids, id)
	}
	return
}

// ResetQueue reset all changes of the "queue" edge.
func (m *CityMutation) ResetQueue() {
	m.queue = nil
	m.removedqueue = nil
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.x != nil {
		fields = append(fields, city.FieldX)
	}
	if m.y != nil {
		fields = append(fields, city.FieldY)
	}
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	if m.points != nil {
		fields = append(fields, city.FieldPoints)
	}
	if m.wood_production != nil {
		fields = append(fields, city.FieldWoodProduction)
	}
	if m.stone_production != nil {
		fields = append(fields, city.FieldStoneProduction)
	}
	if m.iron_production != nil {
		fields = append(fields, city.FieldIronProduction)
	}
	if m.food_production != nil {
		fields = append(fields, city.FieldFoodProduction)
	}
	if m.wood_stored != nil {
		fields = append(fields, city.FieldWoodStored)
	}
	if m.stone_stored != nil {
		fields = append(fields, city.FieldStoneStored)
	}
	if m.iron_stored != nil {
		fields = append(fields, city.FieldIronStored)
	}
	if m.food_stored != nil {
		fields = append(fields, city.FieldFoodStored)
	}
	if m.wood_limit != nil {
		fields = append(fields, city.FieldWoodLimit)
	}
	if m.stone_limit != nil {
		fields = append(fields, city.FieldStoneLimit)
	}
	if m.iron_limit != nil {
		fields = append(fields, city.FieldIronLimit)
	}
	if m.food_limit != nil {
		fields = append(fields, city.FieldFoodLimit)
	}
	if m.queue_time != nil {
		fields = append(fields, city.FieldQueueTime)
	}
	if m.construction_speed != nil {
		fields = append(fields, city.FieldConstructionSpeed)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldX:
		return m.X()
	case city.FieldY:
		return m.Y()
	case city.FieldName:
		return m.Name()
	case city.FieldPoints:
		return m.Points()
	case city.FieldWoodProduction:
		return m.WoodProduction()
	case city.FieldStoneProduction:
		return m.StoneProduction()
	case city.FieldIronProduction:
		return m.IronProduction()
	case city.FieldFoodProduction:
		return m.FoodProduction()
	case city.FieldWoodStored:
		return m.WoodStored()
	case city.FieldStoneStored:
		return m.StoneStored()
	case city.FieldIronStored:
		return m.IronStored()
	case city.FieldFoodStored:
		return m.FoodStored()
	case city.FieldWoodLimit:
		return m.WoodLimit()
	case city.FieldStoneLimit:
		return m.StoneLimit()
	case city.FieldIronLimit:
		return m.IronLimit()
	case city.FieldFoodLimit:
		return m.FoodLimit()
	case city.FieldQueueTime:
		return m.QueueTime()
	case city.FieldConstructionSpeed:
		return m.ConstructionSpeed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case city.FieldX:
		return m.OldX(ctx)
	case city.FieldY:
		return m.OldY(ctx)
	case city.FieldName:
		return m.OldName(ctx)
	case city.FieldPoints:
		return m.OldPoints(ctx)
	case city.FieldWoodProduction:
		return m.OldWoodProduction(ctx)
	case city.FieldStoneProduction:
		return m.OldStoneProduction(ctx)
	case city.FieldIronProduction:
		return m.OldIronProduction(ctx)
	case city.FieldFoodProduction:
		return m.OldFoodProduction(ctx)
	case city.FieldWoodStored:
		return m.OldWoodStored(ctx)
	case city.FieldStoneStored:
		return m.OldStoneStored(ctx)
	case city.FieldIronStored:
		return m.OldIronStored(ctx)
	case city.FieldFoodStored:
		return m.OldFoodStored(ctx)
	case city.FieldWoodLimit:
		return m.OldWoodLimit(ctx)
	case city.FieldStoneLimit:
		return m.OldStoneLimit(ctx)
	case city.FieldIronLimit:
		return m.OldIronLimit(ctx)
	case city.FieldFoodLimit:
		return m.OldFoodLimit(ctx)
	case city.FieldQueueTime:
		return m.OldQueueTime(ctx)
	case city.FieldConstructionSpeed:
		return m.OldConstructionSpeed(ctx)
	}
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case city.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case city.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case city.FieldWoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWoodProduction(v)
		return nil
	case city.FieldStoneProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoneProduction(v)
		return nil
	case city.FieldIronProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIronProduction(v)
		return nil
	case city.FieldFoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoodProduction(v)
		return nil
	case city.FieldWoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWoodStored(v)
		return nil
	case city.FieldStoneStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoneStored(v)
		return nil
	case city.FieldIronStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIronStored(v)
		return nil
	case city.FieldFoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoodStored(v)
		return nil
	case city.FieldWoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWoodLimit(v)
		return nil
	case city.FieldStoneLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoneLimit(v)
		return nil
	case city.FieldIronLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIronLimit(v)
		return nil
	case city.FieldFoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoodLimit(v)
		return nil
	case city.FieldQueueTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueTime(v)
		return nil
	case city.FieldConstructionSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstructionSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CityMutation) AddedFields() []string {
	var fields []string
	if m.addx != nil {
		fields = append(fields, city.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, city.FieldY)
	}
	if m.addpoints != nil {
		fields = append(fields, city.FieldPoints)
	}
	if m.addwood_production != nil {
		fields = append(fields, city.FieldWoodProduction)
	}
	if m.addstone_production != nil {
		fields = append(fields, city.FieldStoneProduction)
	}
	if m.addiron_production != nil {
		fields = append(fields, city.FieldIronProduction)
	}
	if m.addfood_production != nil {
		fields = append(fields, city.FieldFoodProduction)
	}
	if m.addwood_stored != nil {
		fields = append(fields, city.FieldWoodStored)
	}
	if m.addstone_stored != nil {
		fields = append(fields, city.FieldStoneStored)
	}
	if m.addiron_stored != nil {
		fields = append(fields, city.FieldIronStored)
	}
	if m.addfood_stored != nil {
		fields = append(fields, city.FieldFoodStored)
	}
	if m.addwood_limit != nil {
		fields = append(fields, city.FieldWoodLimit)
	}
	if m.addstone_limit != nil {
		fields = append(fields, city.FieldStoneLimit)
	}
	if m.addiron_limit != nil {
		fields = append(fields, city.FieldIronLimit)
	}
	if m.addfood_limit != nil {
		fields = append(fields, city.FieldFoodLimit)
	}
	if m.addconstruction_speed != nil {
		fields = append(fields, city.FieldConstructionSpeed)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case city.FieldX:
		return m.AddedX()
	case city.FieldY:
		return m.AddedY()
	case city.FieldPoints:
		return m.AddedPoints()
	case city.FieldWoodProduction:
		return m.AddedWoodProduction()
	case city.FieldStoneProduction:
		return m.AddedStoneProduction()
	case city.FieldIronProduction:
		return m.AddedIronProduction()
	case city.FieldFoodProduction:
		return m.AddedFoodProduction()
	case city.FieldWoodStored:
		return m.AddedWoodStored()
	case city.FieldStoneStored:
		return m.AddedStoneStored()
	case city.FieldIronStored:
		return m.AddedIronStored()
	case city.FieldFoodStored:
		return m.AddedFoodStored()
	case city.FieldWoodLimit:
		return m.AddedWoodLimit()
	case city.FieldStoneLimit:
		return m.AddedStoneLimit()
	case city.FieldIronLimit:
		return m.AddedIronLimit()
	case city.FieldFoodLimit:
		return m.AddedFoodLimit()
	case city.FieldConstructionSpeed:
		return m.AddedConstructionSpeed()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case city.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case city.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case city.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case city.FieldWoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWoodProduction(v)
		return nil
	case city.FieldStoneProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoneProduction(v)
		return nil
	case city.FieldIronProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIronProduction(v)
		return nil
	case city.FieldFoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFoodProduction(v)
		return nil
	case city.FieldWoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWoodStored(v)
		return nil
	case city.FieldStoneStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoneStored(v)
		return nil
	case city.FieldIronStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIronStored(v)
		return nil
	case city.FieldFoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFoodStored(v)
		return nil
	case city.FieldWoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWoodLimit(v)
		return nil
	case city.FieldStoneLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoneLimit(v)
		return nil
	case city.FieldIronLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIronLimit(v)
		return nil
	case city.FieldFoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFoodLimit(v)
		return nil
	case city.FieldConstructionSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConstructionSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldX:
		m.ResetX()
		return nil
	case city.FieldY:
		m.ResetY()
		return nil
	case city.FieldName:
		m.ResetName()
		return nil
	case city.FieldPoints:
		m.ResetPoints()
		return nil
	case city.FieldWoodProduction:
		m.ResetWoodProduction()
		return nil
	case city.FieldStoneProduction:
		m.ResetStoneProduction()
		return nil
	case city.FieldIronProduction:
		m.ResetIronProduction()
		return nil
	case city.FieldFoodProduction:
		m.ResetFoodProduction()
		return nil
	case city.FieldWoodStored:
		m.ResetWoodStored()
		return nil
	case city.FieldStoneStored:
		m.ResetStoneStored()
		return nil
	case city.FieldIronStored:
		m.ResetIronStored()
		return nil
	case city.FieldFoodStored:
		m.ResetFoodStored()
		return nil
	case city.FieldWoodLimit:
		m.ResetWoodLimit()
		return nil
	case city.FieldStoneLimit:
		m.ResetStoneLimit()
		return nil
	case city.FieldIronLimit:
		m.ResetIronLimit()
		return nil
	case city.FieldFoodLimit:
		m.ResetFoodLimit()
		return nil
	case city.FieldQueueTime:
		m.ResetQueueTime()
		return nil
	case city.FieldConstructionSpeed:
		m.ResetConstructionSpeed()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, city.EdgeOwner)
	}
	if m.constructions != nil {
		edges = append(edges, city.EdgeConstructions)
	}
	if m.queue != nil {
		edges = append(edges, city.EdgeQueue)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case city.EdgeConstructions:
		ids := make([]ent.Value, 0, len(m.constructions))
		for id := range m.constructions {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.queue))
		for id := range m.queue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedconstructions != nil {
		edges = append(edges, city.EdgeConstructions)
	}
	if m.removedqueue != nil {
		edges = append(edges, city.EdgeQueue)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeConstructions:
		ids := make([]ent.Value, 0, len(m.removedconstructions))
		for id := range m.removedconstructions {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.removedqueue))
		for id := range m.removedqueue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, city.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	case city.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgeOwner:
		m.ResetOwner()
		return nil
	case city.EdgeConstructions:
		m.ResetConstructions()
		return nil
	case city.EdgeQueue:
		m.ResetQueue()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// ConstructionMutation represents an operation that mutate the Constructions
// nodes in the graph.
type ConstructionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	x                  *int
	addx               *int
	y                  *int
	addy               *int
	raw_production     *int
	addraw_production  *int
	production         *int
	addproduction      *int
	_type              *int
	add_type           *int
	level              *int
	addlevel           *int
	modifier           *int
	addmodifier        *int
	need_refresh       *bool
	clearedFields      map[string]struct{}
	city               *int
	clearedcity        bool
	owner              *int
	clearedowner       bool
	queue              map[int]struct{}
	removedqueue       map[int]struct{}
	affects            map[int]struct{}
	removedaffects     map[int]struct{}
	affected_by        map[int]struct{}
	removedaffected_by map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Construction, error)
}

var _ ent.Mutation = (*ConstructionMutation)(nil)

// constructionOption allows to manage the mutation configuration using functional options.
type constructionOption func(*ConstructionMutation)

// newConstructionMutation creates new mutation for $n.Name.
func newConstructionMutation(c config, op Op, opts ...constructionOption) *ConstructionMutation {
	m := &ConstructionMutation{
		config:        c,
		op:            op,
		typ:           TypeConstruction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConstructionID sets the id field of the mutation.
func withConstructionID(id int) constructionOption {
	return func(m *ConstructionMutation) {
		var (
			err   error
			once  sync.Once
			value *Construction
		)
		m.oldValue = func(ctx context.Context) (*Construction, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Construction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConstruction sets the old Construction of the mutation.
func withConstruction(node *Construction) constructionOption {
	return func(m *ConstructionMutation) {
		m.oldValue = func(context.Context) (*Construction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConstructionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConstructionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ConstructionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetX sets the x field.
func (m *ConstructionMutation) SetX(i int) {
	m.x = &i
	m.addx = nil
}

// X returns the x value in the mutation.
func (m *ConstructionMutation) X() (r int, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old x value of the Construction.
// If the Construction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConstructionMutation) OldX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldX is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// AddX adds i to x.
func (m *ConstructionMutation) AddX(i int) {
	if m.addx != nil {
		*m.addx += i
	} else {
		m.addx = &i
	}
}

// AddedX returns the value that was added to the x field in this mutation.
func (m *ConstructionMutation) AddedX() (r int, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX reset all changes of the "x" field.
func (m *ConstructionMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the y field.
func (m *ConstructionMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the y value in the mutation.
func (m *ConstructionMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old y value of the Construction.
// If the Construction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConstructionMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to y.
func (m *ConstructionMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the y field in this mutation.
func (m *ConstructionMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY reset all changes of the "y" field.
func (m *ConstructionMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetRawProduction sets the raw_production field.
func (m *ConstructionMutation) SetRawProduction(i int) {
	m.raw_production = &i
	m.addraw_production = nil
}

// RawProduction returns the raw_production value in the mutation.
func (m *ConstructionMutation) RawProduction() (r int, exists bool) {
	v := m.raw_production
	if v == nil {
		return
	}
	return *v, true
}

// OldRawProduction returns the old raw_production value of the Construction.
// If the Construction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConstructionMutation) OldRawProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRawProduction is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRawProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawProduction: %w", err)
	}
	return oldValue.RawProduction, nil
}

// AddRawProduction adds i to raw_production.
func (m *ConstructionMutation) AddRawProduction(i int) {
	if m.addraw_production != nil {
		*m.addraw_production += i
	} else {
		m.addraw_production = &i
	}
}

// AddedRawProduction returns the value that was added to the raw_production field in this mutation.
func (m *ConstructionMutation) AddedRawProduction() (r int, exists bool) {
	v := m.addraw_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetRawProduction reset all changes of the "raw_production" field.
func (m *ConstructionMutation) ResetRawProduction() {
	m.raw_production = nil
	m.addraw_production = nil
}

// SetProduction sets the production field.
func (m *ConstructionMutation) SetProduction(i int) {
	m.production = &i
	m.addproduction = nil
}

// Production returns the production value in the mutation.
func (m *ConstructionMutation) Production() (r int, exists bool) {
	v := m.production
	if v == nil {
		return
	}
	return *v, true
}

// OldProduction returns the old production value of the Construction.
// If the Construction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConstructionMutation) OldProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProduction is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProduction: %w", err)
	}
	return oldValue.Production, nil
}

// AddProduction adds i to production.
func (m *ConstructionMutation) AddProduction(i int) {
	if m.addproduction != nil {
		*m.addproduction += i
	} else {
		m.addproduction = &i
	}
}

// AddedProduction returns the value that was added to the production field in this mutation.
func (m *ConstructionMutation) AddedProduction() (r int, exists bool) {
	v := m.addproduction
	if v == nil {
		return
	}
	return *v, true
}

// ResetProduction reset all changes of the "production" field.
func (m *ConstructionMutation) ResetProduction() {
	m.production = nil
	m.addproduction = nil
}

// SetType sets the type field.
func (m *ConstructionMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the type value in the mutation.
func (m *ConstructionMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Construction.
// If the Construction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConstructionMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to type.
func (m *ConstructionMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the type field in this mutation.
func (m *ConstructionMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the "type" field.
func (m *ConstructionMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetLevel sets the level field.
func (m *ConstructionMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the level value in the mutation.
func (m *ConstructionMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old level value of the Construction.
// If the Construction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConstructionMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to level.
func (m *ConstructionMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the level field in this mutation.
func (m *ConstructionMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel reset all changes of the "level" field.
func (m *ConstructionMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetModifier sets the modifier field.
func (m *ConstructionMutation) SetModifier(i int) {
	m.modifier = &i
	m.addmodifier = nil
}

// Modifier returns the modifier value in the mutation.
func (m *ConstructionMutation) Modifier() (r int, exists bool) {
	v := m.modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldModifier returns the old modifier value of the Construction.
// If the Construction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConstructionMutation) OldModifier(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldModifier is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifier: %w", err)
	}
	return oldValue.Modifier, nil
}

// AddModifier adds i to modifier.
func (m *ConstructionMutation) AddModifier(i int) {
	if m.addmodifier != nil {
		*m.addmodifier += i
	} else {
		m.addmodifier = &i
	}
}

// AddedModifier returns the value that was added to the modifier field in this mutation.
func (m *ConstructionMutation) AddedModifier() (r int, exists bool) {
	v := m.addmodifier
	if v == nil {
		return
	}
	return *v, true
}

// ResetModifier reset all changes of the "modifier" field.
func (m *ConstructionMutation) ResetModifier() {
	m.modifier = nil
	m.addmodifier = nil
}

// SetNeedRefresh sets the need_refresh field.
func (m *ConstructionMutation) SetNeedRefresh(b bool) {
	m.need_refresh = &b
}

// NeedRefresh returns the need_refresh value in the mutation.
func (m *ConstructionMutation) NeedRefresh() (r bool, exists bool) {
	v := m.need_refresh
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedRefresh returns the old need_refresh value of the Construction.
// If the Construction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConstructionMutation) OldNeedRefresh(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNeedRefresh is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNeedRefresh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedRefresh: %w", err)
	}
	return oldValue.NeedRefresh, nil
}

// ResetNeedRefresh reset all changes of the "need_refresh" field.
func (m *ConstructionMutation) ResetNeedRefresh() {
	m.need_refresh = nil
}

// SetCityID sets the city edge to City by id.
func (m *ConstructionMutation) SetCityID(id int) {
	m.city = &id
}

// ClearCity clears the city edge to City.
func (m *ConstructionMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared returns if the edge city was cleared.
func (m *ConstructionMutation) CityCleared() bool {
	return m.clearedcity
}

// CityID returns the city id in the mutation.
func (m *ConstructionMutation) CityID() (id int, exists bool) {
	if m.city != nil {
		return *m.city, true
	}
	return
}

// CityIDs returns the city ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *ConstructionMutation) CityIDs() (ids []int) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity reset all changes of the "city" edge.
func (m *ConstructionMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// SetOwnerID sets the owner edge to User by id.
func (m *ConstructionMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to User.
func (m *ConstructionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *ConstructionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *ConstructionMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ConstructionMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *ConstructionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddQueueIDs adds the queue edge to QueueItem by ids.
func (m *ConstructionMutation) AddQueueIDs(ids ...int) {
	if m.queue == nil {
		m.queue = make(map[int]struct{})
	}
	for i := range ids {
		m.queue[ids[i]] = struct{}{}
	}
}

// RemoveQueueIDs removes the queue edge to QueueItem by ids.
func (m *ConstructionMutation) RemoveQueueIDs(ids ...int) {
	if m.removedqueue == nil {
		m.removedqueue = make(map[int]struct{})
	}
	for i := range ids {
		m.removedqueue[ids[i]] = struct{}{}
	}
}

// RemovedQueue returns the removed ids of queue.
func (m *ConstructionMutation) RemovedQueueIDs() (ids []int) {
	for id := range m.removedqueue {
		ids = append(ids, id)
	}
	return
}

// QueueIDs returns the queue ids in the mutation.
func (m *ConstructionMutation) QueueIDs() (ids []int) {
	for id := range m.queue {
		ids = append(ids, id)
	}
	return
}

// ResetQueue reset all changes of the "queue" edge.
func (m *ConstructionMutation) ResetQueue() {
	m.queue = nil
	m.removedqueue = nil
}

// AddAffectIDs adds the affects edge to Construction by ids.
func (m *ConstructionMutation) AddAffectIDs(ids ...int) {
	if m.affects == nil {
		m.affects = make(map[int]struct{})
	}
	for i := range ids {
		m.affects[ids[i]] = struct{}{}
	}
}

// RemoveAffectIDs removes the affects edge to Construction by ids.
func (m *ConstructionMutation) RemoveAffectIDs(ids ...int) {
	if m.removedaffects == nil {
		m.removedaffects = make(map[int]struct{})
	}
	for i := range ids {
		m.removedaffects[ids[i]] = struct{}{}
	}
}

// RemovedAffects returns the removed ids of affects.
func (m *ConstructionMutation) RemovedAffectsIDs() (ids []int) {
	for id := range m.removedaffects {
		ids = append(ids, id)
	}
	return
}

// AffectsIDs returns the affects ids in the mutation.
func (m *ConstructionMutation) AffectsIDs() (ids []int) {
	for id := range m.affects {
		ids = append(ids, id)
	}
	return
}

// ResetAffects reset all changes of the "affects" edge.
func (m *ConstructionMutation) ResetAffects() {
	m.affects = nil
	m.removedaffects = nil
}

// AddAffectedByIDs adds the affected_by edge to Construction by ids.
func (m *ConstructionMutation) AddAffectedByIDs(ids ...int) {
	if m.affected_by == nil {
		m.affected_by = make(map[int]struct{})
	}
	for i := range ids {
		m.affected_by[ids[i]] = struct{}{}
	}
}

// RemoveAffectedByIDs removes the affected_by edge to Construction by ids.
func (m *ConstructionMutation) RemoveAffectedByIDs(ids ...int) {
	if m.removedaffected_by == nil {
		m.removedaffected_by = make(map[int]struct{})
	}
	for i := range ids {
		m.removedaffected_by[ids[i]] = struct{}{}
	}
}

// RemovedAffectedBy returns the removed ids of affected_by.
func (m *ConstructionMutation) RemovedAffectedByIDs() (ids []int) {
	for id := range m.removedaffected_by {
		ids = append(ids, id)
	}
	return
}

// AffectedByIDs returns the affected_by ids in the mutation.
func (m *ConstructionMutation) AffectedByIDs() (ids []int) {
	for id := range m.affected_by {
		ids = append(ids, id)
	}
	return
}

// ResetAffectedBy reset all changes of the "affected_by" edge.
func (m *ConstructionMutation) ResetAffectedBy() {
	m.affected_by = nil
	m.removedaffected_by = nil
}

// Op returns the operation name.
func (m *ConstructionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Construction).
func (m *ConstructionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ConstructionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.x != nil {
		fields = append(fields, construction.FieldX)
	}
	if m.y != nil {
		fields = append(fields, construction.FieldY)
	}
	if m.raw_production != nil {
		fields = append(fields, construction.FieldRawProduction)
	}
	if m.production != nil {
		fields = append(fields, construction.FieldProduction)
	}
	if m._type != nil {
		fields = append(fields, construction.FieldType)
	}
	if m.level != nil {
		fields = append(fields, construction.FieldLevel)
	}
	if m.modifier != nil {
		fields = append(fields, construction.FieldModifier)
	}
	if m.need_refresh != nil {
		fields = append(fields, construction.FieldNeedRefresh)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ConstructionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case construction.FieldX:
		return m.X()
	case construction.FieldY:
		return m.Y()
	case construction.FieldRawProduction:
		return m.RawProduction()
	case construction.FieldProduction:
		return m.Production()
	case construction.FieldType:
		return m.GetType()
	case construction.FieldLevel:
		return m.Level()
	case construction.FieldModifier:
		return m.Modifier()
	case construction.FieldNeedRefresh:
		return m.NeedRefresh()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ConstructionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case construction.FieldX:
		return m.OldX(ctx)
	case construction.FieldY:
		return m.OldY(ctx)
	case construction.FieldRawProduction:
		return m.OldRawProduction(ctx)
	case construction.FieldProduction:
		return m.OldProduction(ctx)
	case construction.FieldType:
		return m.OldType(ctx)
	case construction.FieldLevel:
		return m.OldLevel(ctx)
	case construction.FieldModifier:
		return m.OldModifier(ctx)
	case construction.FieldNeedRefresh:
		return m.OldNeedRefresh(ctx)
	}
	return nil, fmt.Errorf("unknown Construction field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConstructionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case construction.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case construction.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case construction.FieldRawProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawProduction(v)
		return nil
	case construction.FieldProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProduction(v)
		return nil
	case construction.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case construction.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case construction.FieldModifier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifier(v)
		return nil
	case construction.FieldNeedRefresh:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedRefresh(v)
		return nil
	}
	return fmt.Errorf("unknown Construction field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ConstructionMutation) AddedFields() []string {
	var fields []string
	if m.addx != nil {
		fields = append(fields, construction.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, construction.FieldY)
	}
	if m.addraw_production != nil {
		fields = append(fields, construction.FieldRawProduction)
	}
	if m.addproduction != nil {
		fields = append(fields, construction.FieldProduction)
	}
	if m.add_type != nil {
		fields = append(fields, construction.FieldType)
	}
	if m.addlevel != nil {
		fields = append(fields, construction.FieldLevel)
	}
	if m.addmodifier != nil {
		fields = append(fields, construction.FieldModifier)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ConstructionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case construction.FieldX:
		return m.AddedX()
	case construction.FieldY:
		return m.AddedY()
	case construction.FieldRawProduction:
		return m.AddedRawProduction()
	case construction.FieldProduction:
		return m.AddedProduction()
	case construction.FieldType:
		return m.AddedType()
	case construction.FieldLevel:
		return m.AddedLevel()
	case construction.FieldModifier:
		return m.AddedModifier()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConstructionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case construction.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case construction.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case construction.FieldRawProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRawProduction(v)
		return nil
	case construction.FieldProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProduction(v)
		return nil
	case construction.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case construction.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case construction.FieldModifier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModifier(v)
		return nil
	}
	return fmt.Errorf("unknown Construction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ConstructionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ConstructionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConstructionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Construction nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ConstructionMutation) ResetField(name string) error {
	switch name {
	case construction.FieldX:
		m.ResetX()
		return nil
	case construction.FieldY:
		m.ResetY()
		return nil
	case construction.FieldRawProduction:
		m.ResetRawProduction()
		return nil
	case construction.FieldProduction:
		m.ResetProduction()
		return nil
	case construction.FieldType:
		m.ResetType()
		return nil
	case construction.FieldLevel:
		m.ResetLevel()
		return nil
	case construction.FieldModifier:
		m.ResetModifier()
		return nil
	case construction.FieldNeedRefresh:
		m.ResetNeedRefresh()
		return nil
	}
	return fmt.Errorf("unknown Construction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ConstructionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.city != nil {
		edges = append(edges, construction.EdgeCity)
	}
	if m.owner != nil {
		edges = append(edges, construction.EdgeOwner)
	}
	if m.queue != nil {
		edges = append(edges, construction.EdgeQueue)
	}
	if m.affects != nil {
		edges = append(edges, construction.EdgeAffects)
	}
	if m.affected_by != nil {
		edges = append(edges, construction.EdgeAffectedBy)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ConstructionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case construction.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case construction.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case construction.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.queue))
		for id := range m.queue {
			ids = append(ids, id)
		}
		return ids
	case construction.EdgeAffects:
		ids := make([]ent.Value, 0, len(m.affects))
		for id := range m.affects {
			ids = append(ids, id)
		}
		return ids
	case construction.EdgeAffectedBy:
		ids := make([]ent.Value, 0, len(m.affected_by))
		for id := range m.affected_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ConstructionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedqueue != nil {
		edges = append(edges, construction.EdgeQueue)
	}
	if m.removedaffects != nil {
		edges = append(edges, construction.EdgeAffects)
	}
	if m.removedaffected_by != nil {
		edges = append(edges, construction.EdgeAffectedBy)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ConstructionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case construction.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.removedqueue))
		for id := range m.removedqueue {
			ids = append(ids, id)
		}
		return ids
	case construction.EdgeAffects:
		ids := make([]ent.Value, 0, len(m.removedaffects))
		for id := range m.removedaffects {
			ids = append(ids, id)
		}
		return ids
	case construction.EdgeAffectedBy:
		ids := make([]ent.Value, 0, len(m.removedaffected_by))
		for id := range m.removedaffected_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ConstructionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcity {
		edges = append(edges, construction.EdgeCity)
	}
	if m.clearedowner {
		edges = append(edges, construction.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ConstructionMutation) EdgeCleared(name string) bool {
	switch name {
	case construction.EdgeCity:
		return m.clearedcity
	case construction.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ConstructionMutation) ClearEdge(name string) error {
	switch name {
	case construction.EdgeCity:
		m.ClearCity()
		return nil
	case construction.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Construction unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ConstructionMutation) ResetEdge(name string) error {
	switch name {
	case construction.EdgeCity:
		m.ResetCity()
		return nil
	case construction.EdgeOwner:
		m.ResetOwner()
		return nil
	case construction.EdgeQueue:
		m.ResetQueue()
		return nil
	case construction.EdgeAffects:
		m.ResetAffects()
		return nil
	case construction.EdgeAffectedBy:
		m.ResetAffectedBy()
		return nil
	}
	return fmt.Errorf("unknown Construction edge %s", name)
}

// QueueItemMutation represents an operation that mutate the QueueItems
// nodes in the graph.
type QueueItemMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	start_at            *time.Time
	duration            *int
	addduration         *int
	completion          *time.Time
	action              *int
	addaction           *int
	order               *int
	addorder            *int
	clearedFields       map[string]struct{}
	owner               *int
	clearedowner        bool
	city                *int
	clearedcity         bool
	construction        *int
	clearedconstruction bool
	done                bool
	oldValue            func(context.Context) (*QueueItem, error)
}

var _ ent.Mutation = (*QueueItemMutation)(nil)

// queueitemOption allows to manage the mutation configuration using functional options.
type queueitemOption func(*QueueItemMutation)

// newQueueItemMutation creates new mutation for $n.Name.
func newQueueItemMutation(c config, op Op, opts ...queueitemOption) *QueueItemMutation {
	m := &QueueItemMutation{
		config:        c,
		op:            op,
		typ:           TypeQueueItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQueueItemID sets the id field of the mutation.
func withQueueItemID(id int) queueitemOption {
	return func(m *QueueItemMutation) {
		var (
			err   error
			once  sync.Once
			value *QueueItem
		)
		m.oldValue = func(ctx context.Context) (*QueueItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().QueueItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQueueItem sets the old QueueItem of the mutation.
func withQueueItem(node *QueueItem) queueitemOption {
	return func(m *QueueItemMutation) {
		m.oldValue = func(context.Context) (*QueueItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QueueItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QueueItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *QueueItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStartAt sets the start_at field.
func (m *QueueItemMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the start_at value in the mutation.
func (m *QueueItemMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old start_at value of the QueueItem.
// If the QueueItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *QueueItemMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt reset all changes of the "start_at" field.
func (m *QueueItemMutation) ResetStartAt() {
	m.start_at = nil
}

// SetDuration sets the duration field.
func (m *QueueItemMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the duration value in the mutation.
func (m *QueueItemMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old duration value of the QueueItem.
// If the QueueItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *QueueItemMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to duration.
func (m *QueueItemMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the duration field in this mutation.
func (m *QueueItemMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration reset all changes of the "duration" field.
func (m *QueueItemMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetCompletion sets the completion field.
func (m *QueueItemMutation) SetCompletion(t time.Time) {
	m.completion = &t
}

// Completion returns the completion value in the mutation.
func (m *QueueItemMutation) Completion() (r time.Time, exists bool) {
	v := m.completion
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletion returns the old completion value of the QueueItem.
// If the QueueItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *QueueItemMutation) OldCompletion(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompletion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompletion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletion: %w", err)
	}
	return oldValue.Completion, nil
}

// ResetCompletion reset all changes of the "completion" field.
func (m *QueueItemMutation) ResetCompletion() {
	m.completion = nil
}

// SetAction sets the action field.
func (m *QueueItemMutation) SetAction(i int) {
	m.action = &i
	m.addaction = nil
}

// Action returns the action value in the mutation.
func (m *QueueItemMutation) Action() (r int, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old action value of the QueueItem.
// If the QueueItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *QueueItemMutation) OldAction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAction is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// AddAction adds i to action.
func (m *QueueItemMutation) AddAction(i int) {
	if m.addaction != nil {
		*m.addaction += i
	} else {
		m.addaction = &i
	}
}

// AddedAction returns the value that was added to the action field in this mutation.
func (m *QueueItemMutation) AddedAction() (r int, exists bool) {
	v := m.addaction
	if v == nil {
		return
	}
	return *v, true
}

// ResetAction reset all changes of the "action" field.
func (m *QueueItemMutation) ResetAction() {
	m.action = nil
	m.addaction = nil
}

// SetOrder sets the order field.
func (m *QueueItemMutation) SetOrder(i int) {
	m.order = &i
	m.addorder = nil
}

// Order returns the order value in the mutation.
func (m *QueueItemMutation) Order() (r int, exists bool) {
	v := m.order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old order value of the QueueItem.
// If the QueueItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *QueueItemMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrder is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to order.
func (m *QueueItemMutation) AddOrder(i int) {
	if m.addorder != nil {
		*m.addorder += i
	} else {
		m.addorder = &i
	}
}

// AddedOrder returns the value that was added to the order field in this mutation.
func (m *QueueItemMutation) AddedOrder() (r int, exists bool) {
	v := m.addorder
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder reset all changes of the "order" field.
func (m *QueueItemMutation) ResetOrder() {
	m.order = nil
	m.addorder = nil
}

// SetOwnerID sets the owner edge to User by id.
func (m *QueueItemMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to User.
func (m *QueueItemMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *QueueItemMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *QueueItemMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *QueueItemMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *QueueItemMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetCityID sets the city edge to City by id.
func (m *QueueItemMutation) SetCityID(id int) {
	m.city = &id
}

// ClearCity clears the city edge to City.
func (m *QueueItemMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared returns if the edge city was cleared.
func (m *QueueItemMutation) CityCleared() bool {
	return m.clearedcity
}

// CityID returns the city id in the mutation.
func (m *QueueItemMutation) CityID() (id int, exists bool) {
	if m.city != nil {
		return *m.city, true
	}
	return
}

// CityIDs returns the city ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *QueueItemMutation) CityIDs() (ids []int) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity reset all changes of the "city" edge.
func (m *QueueItemMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// SetConstructionID sets the construction edge to Construction by id.
func (m *QueueItemMutation) SetConstructionID(id int) {
	m.construction = &id
}

// ClearConstruction clears the construction edge to Construction.
func (m *QueueItemMutation) ClearConstruction() {
	m.clearedconstruction = true
}

// ConstructionCleared returns if the edge construction was cleared.
func (m *QueueItemMutation) ConstructionCleared() bool {
	return m.clearedconstruction
}

// ConstructionID returns the construction id in the mutation.
func (m *QueueItemMutation) ConstructionID() (id int, exists bool) {
	if m.construction != nil {
		return *m.construction, true
	}
	return
}

// ConstructionIDs returns the construction ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ConstructionID instead. It exists only for internal usage by the builders.
func (m *QueueItemMutation) ConstructionIDs() (ids []int) {
	if id := m.construction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConstruction reset all changes of the "construction" edge.
func (m *QueueItemMutation) ResetConstruction() {
	m.construction = nil
	m.clearedconstruction = false
}

// Op returns the operation name.
func (m *QueueItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (QueueItem).
func (m *QueueItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *QueueItemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.start_at != nil {
		fields = append(fields, queueitem.FieldStartAt)
	}
	if m.duration != nil {
		fields = append(fields, queueitem.FieldDuration)
	}
	if m.completion != nil {
		fields = append(fields, queueitem.FieldCompletion)
	}
	if m.action != nil {
		fields = append(fields, queueitem.FieldAction)
	}
	if m.order != nil {
		fields = append(fields, queueitem.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *QueueItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case queueitem.FieldStartAt:
		return m.StartAt()
	case queueitem.FieldDuration:
		return m.Duration()
	case queueitem.FieldCompletion:
		return m.Completion()
	case queueitem.FieldAction:
		return m.Action()
	case queueitem.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *QueueItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case queueitem.FieldStartAt:
		return m.OldStartAt(ctx)
	case queueitem.FieldDuration:
		return m.OldDuration(ctx)
	case queueitem.FieldCompletion:
		return m.OldCompletion(ctx)
	case queueitem.FieldAction:
		return m.OldAction(ctx)
	case queueitem.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown QueueItem field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *QueueItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case queueitem.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case queueitem.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case queueitem.FieldCompletion:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletion(v)
		return nil
	case queueitem.FieldAction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case queueitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown QueueItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *QueueItemMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, queueitem.FieldDuration)
	}
	if m.addaction != nil {
		fields = append(fields, queueitem.FieldAction)
	}
	if m.addorder != nil {
		fields = append(fields, queueitem.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *QueueItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case queueitem.FieldDuration:
		return m.AddedDuration()
	case queueitem.FieldAction:
		return m.AddedAction()
	case queueitem.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *QueueItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case queueitem.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case queueitem.FieldAction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAction(v)
		return nil
	case queueitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown QueueItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *QueueItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *QueueItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *QueueItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown QueueItem nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *QueueItemMutation) ResetField(name string) error {
	switch name {
	case queueitem.FieldStartAt:
		m.ResetStartAt()
		return nil
	case queueitem.FieldDuration:
		m.ResetDuration()
		return nil
	case queueitem.FieldCompletion:
		m.ResetCompletion()
		return nil
	case queueitem.FieldAction:
		m.ResetAction()
		return nil
	case queueitem.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown QueueItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *QueueItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, queueitem.EdgeOwner)
	}
	if m.city != nil {
		edges = append(edges, queueitem.EdgeCity)
	}
	if m.construction != nil {
		edges = append(edges, queueitem.EdgeConstruction)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *QueueItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case queueitem.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case queueitem.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case queueitem.EdgeConstruction:
		if id := m.construction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *QueueItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *QueueItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *QueueItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, queueitem.EdgeOwner)
	}
	if m.clearedcity {
		edges = append(edges, queueitem.EdgeCity)
	}
	if m.clearedconstruction {
		edges = append(edges, queueitem.EdgeConstruction)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *QueueItemMutation) EdgeCleared(name string) bool {
	switch name {
	case queueitem.EdgeOwner:
		return m.clearedowner
	case queueitem.EdgeCity:
		return m.clearedcity
	case queueitem.EdgeConstruction:
		return m.clearedconstruction
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *QueueItemMutation) ClearEdge(name string) error {
	switch name {
	case queueitem.EdgeOwner:
		m.ClearOwner()
		return nil
	case queueitem.EdgeCity:
		m.ClearCity()
		return nil
	case queueitem.EdgeConstruction:
		m.ClearConstruction()
		return nil
	}
	return fmt.Errorf("unknown QueueItem unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *QueueItemMutation) ResetEdge(name string) error {
	switch name {
	case queueitem.EdgeOwner:
		m.ResetOwner()
		return nil
	case queueitem.EdgeCity:
		m.ResetCity()
		return nil
	case queueitem.EdgeConstruction:
		m.ResetConstruction()
		return nil
	}
	return fmt.Errorf("unknown QueueItem edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	email                *string
	password_hash        *string
	gold                 *int
	addgold              *int
	diamonds             *int
	adddiamonds          *int
	darkwood             *int
	adddarkwood          *int
	runestone            *int
	addrunestone         *int
	veritium             *int
	addveritium          *int
	trueseed             *int
	addtrueseed          *int
	rank                 *int
	addrank              *int
	alliance_rank        *int
	addalliance_rank     *int
	clearedFields        map[string]struct{}
	cities               map[int]struct{}
	removedcities        map[int]struct{}
	queue                map[int]struct{}
	removedqueue         map[int]struct{}
	constructions        map[int]struct{}
	removedconstructions map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the password_hash field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the password_hash value in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old password_hash value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPasswordHash is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash reset all changes of the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetGold sets the gold field.
func (m *UserMutation) SetGold(i int) {
	m.gold = &i
	m.addgold = nil
}

// Gold returns the gold value in the mutation.
func (m *UserMutation) Gold() (r int, exists bool) {
	v := m.gold
	if v == nil {
		return
	}
	return *v, true
}

// OldGold returns the old gold value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldGold(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGold is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGold: %w", err)
	}
	return oldValue.Gold, nil
}

// AddGold adds i to gold.
func (m *UserMutation) AddGold(i int) {
	if m.addgold != nil {
		*m.addgold += i
	} else {
		m.addgold = &i
	}
}

// AddedGold returns the value that was added to the gold field in this mutation.
func (m *UserMutation) AddedGold() (r int, exists bool) {
	v := m.addgold
	if v == nil {
		return
	}
	return *v, true
}

// ResetGold reset all changes of the "gold" field.
func (m *UserMutation) ResetGold() {
	m.gold = nil
	m.addgold = nil
}

// SetDiamonds sets the diamonds field.
func (m *UserMutation) SetDiamonds(i int) {
	m.diamonds = &i
	m.adddiamonds = nil
}

// Diamonds returns the diamonds value in the mutation.
func (m *UserMutation) Diamonds() (r int, exists bool) {
	v := m.diamonds
	if v == nil {
		return
	}
	return *v, true
}

// OldDiamonds returns the old diamonds value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDiamonds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiamonds is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiamonds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiamonds: %w", err)
	}
	return oldValue.Diamonds, nil
}

// AddDiamonds adds i to diamonds.
func (m *UserMutation) AddDiamonds(i int) {
	if m.adddiamonds != nil {
		*m.adddiamonds += i
	} else {
		m.adddiamonds = &i
	}
}

// AddedDiamonds returns the value that was added to the diamonds field in this mutation.
func (m *UserMutation) AddedDiamonds() (r int, exists bool) {
	v := m.adddiamonds
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiamonds reset all changes of the "diamonds" field.
func (m *UserMutation) ResetDiamonds() {
	m.diamonds = nil
	m.adddiamonds = nil
}

// SetDarkwood sets the darkwood field.
func (m *UserMutation) SetDarkwood(i int) {
	m.darkwood = &i
	m.adddarkwood = nil
}

// Darkwood returns the darkwood value in the mutation.
func (m *UserMutation) Darkwood() (r int, exists bool) {
	v := m.darkwood
	if v == nil {
		return
	}
	return *v, true
}

// OldDarkwood returns the old darkwood value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDarkwood(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDarkwood is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDarkwood requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDarkwood: %w", err)
	}
	return oldValue.Darkwood, nil
}

// AddDarkwood adds i to darkwood.
func (m *UserMutation) AddDarkwood(i int) {
	if m.adddarkwood != nil {
		*m.adddarkwood += i
	} else {
		m.adddarkwood = &i
	}
}

// AddedDarkwood returns the value that was added to the darkwood field in this mutation.
func (m *UserMutation) AddedDarkwood() (r int, exists bool) {
	v := m.adddarkwood
	if v == nil {
		return
	}
	return *v, true
}

// ResetDarkwood reset all changes of the "darkwood" field.
func (m *UserMutation) ResetDarkwood() {
	m.darkwood = nil
	m.adddarkwood = nil
}

// SetRunestone sets the runestone field.
func (m *UserMutation) SetRunestone(i int) {
	m.runestone = &i
	m.addrunestone = nil
}

// Runestone returns the runestone value in the mutation.
func (m *UserMutation) Runestone() (r int, exists bool) {
	v := m.runestone
	if v == nil {
		return
	}
	return *v, true
}

// OldRunestone returns the old runestone value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldRunestone(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRunestone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRunestone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunestone: %w", err)
	}
	return oldValue.Runestone, nil
}

// AddRunestone adds i to runestone.
func (m *UserMutation) AddRunestone(i int) {
	if m.addrunestone != nil {
		*m.addrunestone += i
	} else {
		m.addrunestone = &i
	}
}

// AddedRunestone returns the value that was added to the runestone field in this mutation.
func (m *UserMutation) AddedRunestone() (r int, exists bool) {
	v := m.addrunestone
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunestone reset all changes of the "runestone" field.
func (m *UserMutation) ResetRunestone() {
	m.runestone = nil
	m.addrunestone = nil
}

// SetVeritium sets the veritium field.
func (m *UserMutation) SetVeritium(i int) {
	m.veritium = &i
	m.addveritium = nil
}

// Veritium returns the veritium value in the mutation.
func (m *UserMutation) Veritium() (r int, exists bool) {
	v := m.veritium
	if v == nil {
		return
	}
	return *v, true
}

// OldVeritium returns the old veritium value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldVeritium(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVeritium is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVeritium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVeritium: %w", err)
	}
	return oldValue.Veritium, nil
}

// AddVeritium adds i to veritium.
func (m *UserMutation) AddVeritium(i int) {
	if m.addveritium != nil {
		*m.addveritium += i
	} else {
		m.addveritium = &i
	}
}

// AddedVeritium returns the value that was added to the veritium field in this mutation.
func (m *UserMutation) AddedVeritium() (r int, exists bool) {
	v := m.addveritium
	if v == nil {
		return
	}
	return *v, true
}

// ResetVeritium reset all changes of the "veritium" field.
func (m *UserMutation) ResetVeritium() {
	m.veritium = nil
	m.addveritium = nil
}

// SetTrueseed sets the trueseed field.
func (m *UserMutation) SetTrueseed(i int) {
	m.trueseed = &i
	m.addtrueseed = nil
}

// Trueseed returns the trueseed value in the mutation.
func (m *UserMutation) Trueseed() (r int, exists bool) {
	v := m.trueseed
	if v == nil {
		return
	}
	return *v, true
}

// OldTrueseed returns the old trueseed value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldTrueseed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTrueseed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTrueseed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrueseed: %w", err)
	}
	return oldValue.Trueseed, nil
}

// AddTrueseed adds i to trueseed.
func (m *UserMutation) AddTrueseed(i int) {
	if m.addtrueseed != nil {
		*m.addtrueseed += i
	} else {
		m.addtrueseed = &i
	}
}

// AddedTrueseed returns the value that was added to the trueseed field in this mutation.
func (m *UserMutation) AddedTrueseed() (r int, exists bool) {
	v := m.addtrueseed
	if v == nil {
		return
	}
	return *v, true
}

// ResetTrueseed reset all changes of the "trueseed" field.
func (m *UserMutation) ResetTrueseed() {
	m.trueseed = nil
	m.addtrueseed = nil
}

// SetRank sets the rank field.
func (m *UserMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the rank value in the mutation.
func (m *UserMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old rank value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRank is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to rank.
func (m *UserMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the rank field in this mutation.
func (m *UserMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank reset all changes of the "rank" field.
func (m *UserMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetAllianceRank sets the alliance_rank field.
func (m *UserMutation) SetAllianceRank(i int) {
	m.alliance_rank = &i
	m.addalliance_rank = nil
}

// AllianceRank returns the alliance_rank value in the mutation.
func (m *UserMutation) AllianceRank() (r int, exists bool) {
	v := m.alliance_rank
	if v == nil {
		return
	}
	return *v, true
}

// OldAllianceRank returns the old alliance_rank value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAllianceRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAllianceRank is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAllianceRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllianceRank: %w", err)
	}
	return oldValue.AllianceRank, nil
}

// AddAllianceRank adds i to alliance_rank.
func (m *UserMutation) AddAllianceRank(i int) {
	if m.addalliance_rank != nil {
		*m.addalliance_rank += i
	} else {
		m.addalliance_rank = &i
	}
}

// AddedAllianceRank returns the value that was added to the alliance_rank field in this mutation.
func (m *UserMutation) AddedAllianceRank() (r int, exists bool) {
	v := m.addalliance_rank
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllianceRank reset all changes of the "alliance_rank" field.
func (m *UserMutation) ResetAllianceRank() {
	m.alliance_rank = nil
	m.addalliance_rank = nil
}

// AddCityIDs adds the cities edge to City by ids.
func (m *UserMutation) AddCityIDs(ids ...int) {
	if m.cities == nil {
		m.cities = make(map[int]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// RemoveCityIDs removes the cities edge to City by ids.
func (m *UserMutation) RemoveCityIDs(ids ...int) {
	if m.removedcities == nil {
		m.removedcities = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed ids of cities.
func (m *UserMutation) RemovedCitiesIDs() (ids []int) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the cities ids in the mutation.
func (m *UserMutation) CitiesIDs() (ids []int) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities reset all changes of the "cities" edge.
func (m *UserMutation) ResetCities() {
	m.cities = nil
	m.removedcities = nil
}

// AddQueueIDs adds the queue edge to QueueItem by ids.
func (m *UserMutation) AddQueueIDs(ids ...int) {
	if m.queue == nil {
		m.queue = make(map[int]struct{})
	}
	for i := range ids {
		m.queue[ids[i]] = struct{}{}
	}
}

// RemoveQueueIDs removes the queue edge to QueueItem by ids.
func (m *UserMutation) RemoveQueueIDs(ids ...int) {
	if m.removedqueue == nil {
		m.removedqueue = make(map[int]struct{})
	}
	for i := range ids {
		m.removedqueue[ids[i]] = struct{}{}
	}
}

// RemovedQueue returns the removed ids of queue.
func (m *UserMutation) RemovedQueueIDs() (ids []int) {
	for id := range m.removedqueue {
		ids = append(ids, id)
	}
	return
}

// QueueIDs returns the queue ids in the mutation.
func (m *UserMutation) QueueIDs() (ids []int) {
	for id := range m.queue {
		ids = append(ids, id)
	}
	return
}

// ResetQueue reset all changes of the "queue" edge.
func (m *UserMutation) ResetQueue() {
	m.queue = nil
	m.removedqueue = nil
}

// AddConstructionIDs adds the constructions edge to Construction by ids.
func (m *UserMutation) AddConstructionIDs(ids ...int) {
	if m.constructions == nil {
		m.constructions = make(map[int]struct{})
	}
	for i := range ids {
		m.constructions[ids[i]] = struct{}{}
	}
}

// RemoveConstructionIDs removes the constructions edge to Construction by ids.
func (m *UserMutation) RemoveConstructionIDs(ids ...int) {
	if m.removedconstructions == nil {
		m.removedconstructions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedconstructions[ids[i]] = struct{}{}
	}
}

// RemovedConstructions returns the removed ids of constructions.
func (m *UserMutation) RemovedConstructionsIDs() (ids []int) {
	for id := range m.removedconstructions {
		ids = append(ids, id)
	}
	return
}

// ConstructionsIDs returns the constructions ids in the mutation.
func (m *UserMutation) ConstructionsIDs() (ids []int) {
	for id := range m.constructions {
		ids = append(ids, id)
	}
	return
}

// ResetConstructions reset all changes of the "constructions" edge.
func (m *UserMutation) ResetConstructions() {
	m.constructions = nil
	m.removedconstructions = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.gold != nil {
		fields = append(fields, user.FieldGold)
	}
	if m.diamonds != nil {
		fields = append(fields, user.FieldDiamonds)
	}
	if m.darkwood != nil {
		fields = append(fields, user.FieldDarkwood)
	}
	if m.runestone != nil {
		fields = append(fields, user.FieldRunestone)
	}
	if m.veritium != nil {
		fields = append(fields, user.FieldVeritium)
	}
	if m.trueseed != nil {
		fields = append(fields, user.FieldTrueseed)
	}
	if m.rank != nil {
		fields = append(fields, user.FieldRank)
	}
	if m.alliance_rank != nil {
		fields = append(fields, user.FieldAllianceRank)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldGold:
		return m.Gold()
	case user.FieldDiamonds:
		return m.Diamonds()
	case user.FieldDarkwood:
		return m.Darkwood()
	case user.FieldRunestone:
		return m.Runestone()
	case user.FieldVeritium:
		return m.Veritium()
	case user.FieldTrueseed:
		return m.Trueseed()
	case user.FieldRank:
		return m.Rank()
	case user.FieldAllianceRank:
		return m.AllianceRank()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldGold:
		return m.OldGold(ctx)
	case user.FieldDiamonds:
		return m.OldDiamonds(ctx)
	case user.FieldDarkwood:
		return m.OldDarkwood(ctx)
	case user.FieldRunestone:
		return m.OldRunestone(ctx)
	case user.FieldVeritium:
		return m.OldVeritium(ctx)
	case user.FieldTrueseed:
		return m.OldTrueseed(ctx)
	case user.FieldRank:
		return m.OldRank(ctx)
	case user.FieldAllianceRank:
		return m.OldAllianceRank(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGold(v)
		return nil
	case user.FieldDiamonds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiamonds(v)
		return nil
	case user.FieldDarkwood:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDarkwood(v)
		return nil
	case user.FieldRunestone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunestone(v)
		return nil
	case user.FieldVeritium:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVeritium(v)
		return nil
	case user.FieldTrueseed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrueseed(v)
		return nil
	case user.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case user.FieldAllianceRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllianceRank(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addgold != nil {
		fields = append(fields, user.FieldGold)
	}
	if m.adddiamonds != nil {
		fields = append(fields, user.FieldDiamonds)
	}
	if m.adddarkwood != nil {
		fields = append(fields, user.FieldDarkwood)
	}
	if m.addrunestone != nil {
		fields = append(fields, user.FieldRunestone)
	}
	if m.addveritium != nil {
		fields = append(fields, user.FieldVeritium)
	}
	if m.addtrueseed != nil {
		fields = append(fields, user.FieldTrueseed)
	}
	if m.addrank != nil {
		fields = append(fields, user.FieldRank)
	}
	if m.addalliance_rank != nil {
		fields = append(fields, user.FieldAllianceRank)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldGold:
		return m.AddedGold()
	case user.FieldDiamonds:
		return m.AddedDiamonds()
	case user.FieldDarkwood:
		return m.AddedDarkwood()
	case user.FieldRunestone:
		return m.AddedRunestone()
	case user.FieldVeritium:
		return m.AddedVeritium()
	case user.FieldTrueseed:
		return m.AddedTrueseed()
	case user.FieldRank:
		return m.AddedRank()
	case user.FieldAllianceRank:
		return m.AddedAllianceRank()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGold(v)
		return nil
	case user.FieldDiamonds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiamonds(v)
		return nil
	case user.FieldDarkwood:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDarkwood(v)
		return nil
	case user.FieldRunestone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunestone(v)
		return nil
	case user.FieldVeritium:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVeritium(v)
		return nil
	case user.FieldTrueseed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTrueseed(v)
		return nil
	case user.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case user.FieldAllianceRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllianceRank(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldGold:
		m.ResetGold()
		return nil
	case user.FieldDiamonds:
		m.ResetDiamonds()
		return nil
	case user.FieldDarkwood:
		m.ResetDarkwood()
		return nil
	case user.FieldRunestone:
		m.ResetRunestone()
		return nil
	case user.FieldVeritium:
		m.ResetVeritium()
		return nil
	case user.FieldTrueseed:
		m.ResetTrueseed()
		return nil
	case user.FieldRank:
		m.ResetRank()
		return nil
	case user.FieldAllianceRank:
		m.ResetAllianceRank()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cities != nil {
		edges = append(edges, user.EdgeCities)
	}
	if m.queue != nil {
		edges = append(edges, user.EdgeQueue)
	}
	if m.constructions != nil {
		edges = append(edges, user.EdgeConstructions)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.queue))
		for id := range m.queue {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConstructions:
		ids := make([]ent.Value, 0, len(m.constructions))
		for id := range m.constructions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcities != nil {
		edges = append(edges, user.EdgeCities)
	}
	if m.removedqueue != nil {
		edges = append(edges, user.EdgeQueue)
	}
	if m.removedconstructions != nil {
		edges = append(edges, user.EdgeConstructions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.removedqueue))
		for id := range m.removedqueue {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConstructions:
		ids := make([]ent.Value, 0, len(m.removedconstructions))
		for id := range m.removedconstructions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCities:
		m.ResetCities()
		return nil
	case user.EdgeQueue:
		m.ResetQueue()
		return nil
	case user.EdgeConstructions:
		m.ResetConstructions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
